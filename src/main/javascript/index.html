<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset = "UTF-8">
    <meta name = "viewport" content = "width=device-width, initial-scale=1.0">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.min.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
  	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
  	
    <title>KLM Report</title>
</head>
<body >
     <div class="container-fluid">
    	<div class="row ">
	        <div class="col-md-12">
	            <h3 > Analysis # </h3>
	        </div>
	    </div>
	    <div class="row ">
	        <div class="col-md-6">
    			<button id="reload" type="button" class="btn btn-outline-dark" data-container="body" data-trigger="hover" data-toggle="modal" data-placement="right" data-target="#exampleModal"><i class="fa fa-question-circle fa-lg"></i>  KLM Sequence
				</button>
	        </div>
	        <div class="col-md-6">
	            <h6 class="text-right" id="klmTime"> </h6>
	        </div>
	</div>

	<!-- Modal -->
<div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-xl" role="document">
    <div class="modal-content">
      <div class="modal-body">
         <p class="text-break" style="display: inline-block;" id="klmSeq"> </p>
      </div>
    </div>
  </div>
</div>


    <div class = "container-fluid" >
        <div style = "margin-top: 20px;" class="row"><!--style="position: relative; height:30vh; width:40vw"-->
            <div class="col-md-4">
                <canvas id = "firstChart" height="180vh"></canvas>
            </div>
            <div class="col-md-4">
                <canvas id = "secondChart" height="180vh"></canvas>
            </div> 
            <div class="col-md-4">
                <canvas id = "thirdChart" height="180vh"></canvas>
            </div> 
        </div>

        <div style = "margin-top: 20px;" class="row" ><!--style="position: relative; height:30vh; width:40vw"-->
            <div class="col-md-12">
   				<canvas id="EventsChart" height="250vh"></canvas>
            </div>
        </div>

        <button style = "margin-top: 25px;" id ="recommendationsBtn" type="button" class="btn btn-dark btn-block"> See Recommendations</button>
  
    </div>


 
	
	<script >
        const reload = document.querySelector('#reload');
        const xLabels = [];
        const yLabels = [];
        const xLabelsEventsChart = [];
        const xLabelsevents = [];
        const xLabelsEventsMatchData = [];
        const yLabelsSecond = [];
        const yLabelsThird = [];
        var countInteractions =0;
        var klmSequence = document.getElementById('klmSeq');
		var klmTime = document.getElementById('klmTime');

        createChart();
        ChartTotalInteractions();
        ChartPercentages();
        createEventsChart();

        document.getElementById("recommendationsBtn").onclick = function () {
            location.href = "http://localhost/webbench/src/main/javascript/recomendationsPage.html";
        };
		
        reload.addEventListener('click', () => {
            document.getElementById('klmSeq').innerHTML = klmSequence;
        });

       async function createChart(){
            await getTimePerOperator();
                var ctx = document.getElementById('firstChart').getContext('2d');             
                var chart = new Chart(ctx, {
                    // The type of chart we want to create
                    type: 'bar',

                    // The data for our dataset
                    data: {
                        labels: xLabels,
                        datasets: [{
                            label: 'Information on the total time for each operator',
                            fontFamily:'Roboto',
                            backgroundColor: 'rgb(0, 0, 0)',
                            borderColor: 'rgb(0, 0, 0)',
                            data: yLabels,
                        }]
                    },

                    // Configuration options go here
                    options: {
                        title: {
                            display: true,
                            fontFamily:'Roboto',
                            text: ['Estimated total time per operator'],
                            fontSize: 16,                          
                        },
                        scales: {
                            yAxes: [{
                                scaleLabel:{
                                    position: 'bottom',
                                    display: true,
                                    labelString: 'Time'
                                },
                                ticks: {
                                    beginAtZero: true,
                                    stepSize: 10,
                                    stepValue: 6,
                                    max: 40
                                }
                            }],
                            xAxes: [{
                                barThickness: 30,  // number (pixels) or 'flex'
                                maxBarThickness: 30, // number (pixels)
                                ticks: {
                                    fontSize:8
                                }
                            }]
                        }, 
                        animation: 
                        {
                            duration: 1,
                            onComplete: function () {
                            var chartInstance = this.chart,
                                ctx = chartInstance.ctx;
                                ctx.textAlign = 'center';
                                ctx.fillStyle = "rgba(0, 0, 0, 1)";
                                ctx.textBaseline = 'bottom';
                                this.data.datasets.forEach(function (dataset, i) {
                                    var meta = chartInstance.controller.getDatasetMeta(i);
                                    meta.data.forEach(function (bar, index) {
                                        var data = dataset.data[index];
                                        ctx.fillText(data, bar._model.x, bar._model.y - 5);
                                    });
                                });
                                }
                        }          
                    }
                });
            }
        
        async function getOperatorsInteractions(){
           await fetch('files/DataToCharts.csv')
            .then(response => response.text())
            .then(text => { console.log(text)
                var csvArray = text.split('\n').slice(1)
                console.log('csvArray ' + csvArray)
                csvArray.forEach( row => {
                 const columns = row.split(';')
                 const times = columns[1]
                    yLabelsSecond.push(times)
             });
            });
            yLabelsSecond.forEach(function(value, index, array){
                if(!isNaN(value) && value > 0){
                    countInteractions = countInteractions + parseInt(value);
                    console.log('VALUES: ' + countInteractions);
                }                                 
            });
        }
   
        async function getTimePerOperator(){
            await fetch('files/DataToCharts.csv')
            .then(response => response.text())
            .then(text => { console.log(text)
                var csvArray = text.split('\n').slice(1)
                console.log('csvArray ' + csvArray)
                csvArray.forEach( row => {
                const columns = row.split(';')
                var klmOperator = columns[0]
                if(klmOperator == 'K'){
                    klmOperator = ['Key Press', '(K)']
                }else if (klmOperator == 'M'){
                    klmOperator = ['Mental','(M)']
                }else if (klmOperator == 'H'){
                    klmOperator = ['Switch (M-K)','(H)']
                }else if (klmOperator == 'B'){
                    klmOperator = ['Mouse click','(B)']
                }else if (klmOperator == 'P'){
                    klmOperator = ['Mouse Point','(P)']
                }else if(klmOperator == 'W'){
                    klmOperator = ['Wait for system','(W)']
                }
                if(klmOperator != "" && columns[0][2] == undefined ){
                    xLabels.push(klmOperator)
                }
                else if(columns[0][2] != undefined){
					var matcheNumber = klmOperator.match(/\d+/g);
					if(matcheNumber != null){
						klmTime.innerHTML = 'Estimated time to complete task: ' + klmOperator + ' secs';
						console.log('Time, Penultima linha:' + klmTime);
					}else{
						klmSequence.innerHTML = klmOperator;
						console.log('elsIF:' + klmSequence);
					}                  
                }
                const times = columns[3]
                console.log('Utilma linha: ' + columns[0][2]);
                yLabels.push(times)
                console.log('operators ' + klmOperator, 'times ' + times)
            });
            });
        }
        
        async function ChartTotalInteractions(){
            await getOperatorsInteractions();
                var ctx = document.getElementById('secondChart').getContext('2d');             
                var chart = new Chart(ctx, {
                    // The type of chart we want to create
                    type: 'bar',
                    // The data for our dataset
                    data: {
                        labels: xLabels,
                        datasets: [{
                            label: 'Distribution of interactions by operators',
                            fontFamily:'Roboto',
                            backgroundColor: 'rgb(0, 0, 0)',
                            borderColor: 'rgb(0, 0, 0)',
                            data: yLabelsSecond
                        }]
                    },

                    // Configuration options go here
                    options: {
                        title: {
                            display: true,
                            fontFamily:'Roboto',
                             text: ['Total Interactions: ' + countInteractions], //ir a cada um dos elemntos e fazer um count
                            fontSize: 16,                          
                        },
                        scales: {
                            yAxes: [{
                                scaleLabel:{
                                    position: 'bottom',
                                    display: true,
                                    labelString: 'Interactions'
                                },
                                ticks: {
                                    beginAtZero: true,
                                    stepSize: 10,
                                    stepValue: 6,
                                    max: 50 //max value for the chart is 60
                                }
                            }],
                            xAxes: [{
                                barThickness: 30,  // number (pixels) or 'flex'
                                maxBarThickness: 30, // number (pixels)
                                ticks: {
                                    fontSize:8
                                }
                            }]
                        }, 
                        animation: 
                        {
                            duration: 1,
                            onComplete: function () {
                            var chartInstance = this.chart,
                                ctx = chartInstance.ctx;
                                ctx.textAlign = 'center';
                                ctx.fillStyle = "rgba(0, 0, 0, 1)";
                                ctx.textBaseline = 'bottom';
                                this.data.datasets.forEach(function (dataset, i) {
                                    var meta = chartInstance.controller.getDatasetMeta(i);
                                    meta.data.forEach(function (bar, index) {
                                        var data = dataset.data[index];
                                        ctx.fillText(data, bar._model.x, bar._model.y - 5);
                                    });
                                });
                                }
                        }                  
                    }
                });

            }

         async function ChartPercentages(){
         await getOperatorsPercentages();
             var ctx = document.getElementById('thirdChart').getContext('2d');             
             var chart = new Chart(ctx, {
                 // The type of chart we want to create
                 type: 'bar',
                 // The data for our dataset
                 data: {
                     labels: xLabels,
                     datasets: [{
                         label: 'Indicators for prevalent operators',
                         fontFamily:'Roboto',
                         backgroundColor: 'rgb(0, 0, 0)',
                         borderColor: 'rgb(0, 0, 0)',
                         data: yLabelsThird
                     }]
                 },

                 // Configuration options go here
                 options: {
                     title: {
                         display: true,
                         fontFamily:'Roboto',
                          text: ['% Operators used'], //ir a cada um dos elemntos e fazer um count
                         fontSize: 16,                          
                     },
                     scales: {
                         yAxes: [{
                             scaleLabel:{
                                 position: 'bottom',
                                 display: true,
                                 labelString: 'percentage(%)'
                             },
                             ticks: {
                                 beginAtZero: true,
                                 stepSize: 20,
                                 stepValue: 6,
                                 max: 100 //max value for the chart is 60
                             }
                         }],
                         xAxes: [{
                             barThickness: 30,  // number (pixels) or 'flex'
                             maxBarThickness: 30, // number (pixels)
                             ticks: {
                                 fontSize:8
                             }
                         }]
                     }, 
                        animation: 
                        {
                            duration: 1,
                            onComplete: function () {
                            var chartInstance = this.chart,
                                ctx = chartInstance.ctx;
                                ctx.textAlign = 'center';
                                ctx.fillStyle = "rgba(0, 0, 0, 1)";
                                ctx.textBaseline = 'bottom';
                                this.data.datasets.forEach(function (dataset, i) {
                                    var meta = chartInstance.controller.getDatasetMeta(i);
                                    meta.data.forEach(function (bar, index) {
                                        var data = dataset.data[index];
                                        ctx.fillText(data, bar._model.x, bar._model.y - 5);
                                    });
                                });
                                }
                        }             
                 }
             });

         }

        async function getOperatorsPercentages(){
            await fetch('files/DataToCharts.csv')
            .then(response => response.text())
            .then(text => { console.log(text)
                var csvArray = text.split('\n').slice(1)
                console.log('csvArray ' + csvArray)
                csvArray.forEach( row => {
                const columns = row.split(';')
                const times = columns[2]
                console.log('Percentages!!! ' + times)
                yLabelsThird.push(times)
            });
            });
        }
    
        async function createEventsChart(){
            await getKlmString();
                var ctx = document.getElementById('EventsChart').getContext('2d');        
                var chart = new Chart(ctx, {
                    // The type of chart we want to create
                    type: 'line',
                    // The data for our dataset
                    data: {
                        labels: xLabelsEventsChart, // --- numbers/Events!!
                        datasets: [{
                            label: "Sequence of events per Operator",
                            fill: false,
                            backgroundColor: 'rgb(0, 0, 0)',
                            borderColor: 'rgb(0, 0, 0)',
                            data: xLabelsEventsMatchData, //MATCH COM A STRING KLM
                            showLine : false
                        }]
                    },

                    // Configuration options go here
                    options: {
                       /* title: {
                            display: true,
                            fontFamily:'Roboto',
                            text: 'Sequence of events per Operator',
                            fontSize: 16,                          
                        },*/
                        responsive:true,
                        maintainAspectRatio: false,
                        scales: {
                            yAxes: [{
                                scaleLabel:{
                                    position: 'bottom',
                                    display: true,
                                    labelString: 'Event'
                                },
                                ticks: {
                                    min: 0,
                                    max: 6,
                                    stepSize: 1,
                                    suggestedMin: 0.5,
                                    suggestedMax: 5.5,
                                    callback: function(label, index, labels) {
                                        switch (label) {
                                            case 1:
                                                return 'M';
                                            case 2:
                                                return 'K';
                                            case 3:
                                                return 'H';
                                            case 4:
                                                return 'P';
                                            case 5:
                                                return 'B';
                                            case 6:
                                                return 'W';
                                        }
                                    }
                                }
                            }],
                            xAxes: [{
                                scaleLabel:{
                                    position: 'bottom',
                                    display: true,
                                    labelString: 'Interactions'
                                },
                                ticks: {
                                    
                                    max: klmSequence.length + 1, // 2 em 2 tem a ver com o tamanho do eixo dos x
                                    min: 0,
                                    stepSize: 1/*,
                                    suggestedMin: 0.5,
                                    suggestedMax: 5.5*/
                                }
                            }]
                        }           
                    }
                });
            }
    async function getKlmString(){
       await fetch('files/DataToCharts.csv')
       .then(response => response.text())
       .then(text => { console.log(text)
           var csvArray = text.split('\n').slice(1)
           console.log('csvArray ' + csvArray)
           csvArray.forEach( row => {
           const columns = row.split(';')
           var klmOperator = columns[0]
           if(columns[0][2] != undefined){
               klmSequence = klmOperator;
               console.log('elsIF:' + klmSequence);
           }
           console.log('CklmSequence ' + klmSequence);
       });
       var count =0;
       for(var i =0;i <= klmSequence.length; i++){               
                xLabelsEventsChart.push(count);
                count++;
                // console.log('xLabelsEventsMatchData: ' + xLabelsEventsMatchData);
                if(klmSequence.charAt(i) == 'K'){ // na definição dos ticks do eixo do y o K é 2
                    xLabelsEventsMatchData.push(2);
                }else if(klmSequence.charAt(i) == 'H'){
                    xLabelsEventsMatchData.push(3);
                }else if(klmSequence.charAt(i) == 'P'){
                    xLabelsEventsMatchData.push(4);
                }else if(klmSequence.charAt(i) == 'B'){
                    xLabelsEventsMatchData.push(5);
                }else if(klmSequence.charAt(i) == 'M'){
                    xLabelsEventsMatchData.push(1);
                }
       }
       console.log('xLabelsEventsMatchData: ' + xLabelsEventsMatchData);
       console.log('xLabelsEventsChart values: ' + xLabelsEventsChart);
    });
      }
   

   </script>

    
</body>
</html>